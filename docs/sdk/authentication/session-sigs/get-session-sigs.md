---
sidebar_position: 2
---

import FeedbackComponent from "@site/src/pages/feedback.md";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Generating SessionSigs: `getSessionSigs`

This guide covers the `getSessionSigs` function from the Lit SDK. For an overview of what session signatures are and how they are to be used, please go [here](./intro).

The function uses the session keypair generated by the `LitNodeClient` to invoke a callback function that signs the generated session key, creating an `AuthSig` that is scoped to specific capabilities.

Using the `getSessionSigs` function, you can specify the abilities of your current session on the Lit network. This function is the simplest way to get session signatures, at the minimum only requiring an `ethers.Wallet` and the `LitNodeClient`. It will enable your `ethers.Wallet` to perform abilities to the resources you specify in the `AuthSig`.

## Prerequisites

Before continuing this guide, you should have an understanding of:
- [Session Signatures](./intro)
- [Lit Resources and Abilities](./resources-and-abilities.md)

## `getSessionSigs`' Interface
[Source code](https://github.com/LIT-Protocol/js-sdk/blob/master/packages/types/src/lib/interfaces.ts#L1057-L1106)

```ts
interface CommonGetSessionSigsProps {
  pkpPublicKey?: string;
  expiration?: any;
  chain?: Chain;
  resourceAbilityRequests: LitResourceAbilityRequest[];
  sessionCapabilityObject?: ISessionCapabilityObject;
  switchChain?: boolean;
  sessionKey?: SessionKeyPair;
  capabilityAuthSigs?: AuthSig[];
}

interface GetSessionSigsProps
  extends CommonGetSessionSigsProps,
    LitActionSdkParams {
  authNeededCallback: AuthCallback;
}

getSessionSigs = async (
    params: GetSessionSigsProps
  ): Promise<SessionSigsMap>

interface AuthSig {
  sig: any;
  derivedVia: string;
  signedMessage: string;
  address: string;
}

type SessionSigsMap = Record<string, AuthSig>;
```

## Parameters

### `pkpPublicKey`
If you want to delegate abilities and resources to a PKP using this function, you would define the public key here.

### `expiration`
 When this session signature will expire. After this time is up, you will need to reauthenticate using the same authentication method, generating a new session signature. The default time until expiration is 24 hours.

### `chain`
 The chain to use for the session signature and sign the session key. If you're using EVM, this parameter isn't very important.

### `resourceAbilityRequests`
An array of resource abilities that you want to request for this session. These will be signed with the session key.
  
If you want to request the ability to decrypt an access control condition, then you would pass:
   ```ts
   [{ resource: new LitAccessControlConditionResource('someResource'), ability: LitAbility.AccessControlConditionDecryption }]
   ```
  
### `sessionCapabilityObjects`
  The session capability object that you want to request for this session. If you pass nothing, then this will default to
  wildcard for each type of resource you're accessing.
  For example, if you passed nothing, and you're requesting to perform a decryption operation for an access control condition, then the session capability object will be a wildcard for the access control condition, which grants this session signature the ability to decrypt this access control condition.

### `switchChain`
If you want to ask Metamask to try and switch the user's chain, you may pass true here.  This will only work if the user is using Metamask.  If the user is not using Metamask, then this will be ignored.

### `sessionKey`
The serialized session key pair to sign. If not provided, a session key pair will be fetched from localStorage or generated.

### `capabilityAuthSigs`
Not limited to capacityDelegationAuthSig, we want to be able to pass in any other authSigs for other purposes.

## Return Value

### `sig`
The signature produced by the ed25519 key pair signing the `signedMessage` payload.

### `derivedVia`
Should be `litSessionSignViaNacl`, specifies that the session signature object was created via the `NaCl` library.

### `signedMessage`
The payload signed by the session key pair. This is the signed `AuthSig`, which includes the fields:

- #### `sessionKey`
   The session key pair public key.
- #### `resourceAbilityRequests`
   An array of resource abilities that you have requested for the session.
- #### `capabilities` <- Needs a fact check
   An array of one or more `AuthSig`. The `capabilities` authorize the `AuthSig` address(es) to utilize the resources specified. in the `resourceAbilityRequests`
- #### `issuedAt`
   The time the session signature was issued.
- #### `expiration`
   The time the session signature becomes invalid.
- #### `nodeAddress`
   The specific URL the session signature is meant for.

### `address`
The session key pair public key.

### `algo`
The signing algorithm used to generate the session signature.

## Example Implementation

Now that we know what the `getSessionSigs` function does, it's parameters, and it's return values, let's dig into a complete implementation.

The full code implementation can be found [here](https://github.com/LIT-Protocol/developer-guides-code/tree/master/session-signatures/getSessionSigs). 

### Installing the Required Dependencies
<Tabs
defaultValue="npm"
values={[
{label: 'npm', value: 'npm'},
{label: 'yarn', value: 'yarn'},
]}>
<TabItem value="npm">

```bash
npm install \
@lit-protocol/auth-helpers \
@lit-protocol/constants \
@lit-protocol/lit-node-client \
node-localstorage \
ethers@v5
```

</TabItem>

<TabItem value="yarn">

```bash
yarn add \
@lit-protocol/auth-helpers \
@lit-protocol/constants \
@lit-protocol/lit-node-client \
node-localstorage \
ethers@v5
```

</TabItem>
</Tabs>



### Instantiating an Ethers Signer
The `ETHEREUM_PRIVATE_KEY` environment variable is required.
```ts
import { LIT_RPC } from "@lit-protocol/constants";
import * as ethers from "ethers";

const ethersSigner = new ethers.Wallet(
  ETHEREUM_PRIVATE_KEY,
  new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)
);
```

### Instantiating a `LitNodeClient`
Here we are instantiating an instance of `LitNodeClient` and connecting it to the `datil-dev` Lit network. To simulate a Node.js environment, we use `LocalStorage` from the `node-localstorage` module to store our session keys and metadata.

```ts
import { LitNodeClient } from "@lit-protocol/lit-node-client";
import { LitNetwork } from "@lit-protocol/constants";
import { LocalStorage } from "node-localstorage";

let litNodeClient: LitNodeClient;

litNodeClient = new LitNodeClient({
      litNetwork: LitNetwork.DatilDev,
      debug: false,
      storageProvider: {
        provider: new LocalStorage("./lit_storage.db"),
      },
    });
await litNodeClient.connect();
```

### Generating Session Signatures
The session signatures generated in this example provide unrestricted access to all resources. However, in real-world applications, it's more common and secure to limit access. Typically, you would use the specific hash of the encrypted access control condition resource key, granting access only to particular resources rather than everything. To this resource, we then give it the ability to decrypt an encryption access control condition. 

```ts
import {
  LitAbility,
  LitAccessControlConditionResource,
  createSiweMessage,
  generateAuthSig,
} from "@lit-protocol/auth-helpers";

const sessionSignatures = await litNodeClient.getSessionSigs({
  chain: "ethereum",
  expiration: new Date(Date.now() + 1000 * 60 * 10 ).toISOString(), // 10 minutes
  resourceAbilityRequests: [
    {
      resource: new LitAccessControlConditionResource("*"),
      ability: LitAbility.AccessControlConditionDecryption,
    },
  ],
  authNeededCallback: async ({
    uri,
    expiration,
    resourceAbilityRequests,
  }) => {
    const toSign = await createSiweMessage({
      uri,
      expiration,
      resources: resourceAbilityRequests,
      walletAddress: await ethersSigner.getAddress(),
      nonce: await litNodeClient.getLatestBlockhash(),
      litNodeClient,
    });

    return await generateAuthSig({
      signer: ethersSigner,
      toSign,
    });
  },
});
```


**Note:** The nonce should be the latest Ethereum blockhash returned by the nodes during the handshake.

## Resources You Can Request

You can pass an array of `resourceAbilityRequests` to the above functions, which will be presented to the user in the SIWE message - read more [here](resources-and-abilities) about Lit resources and abilities. The resources and abilities requested by the session key must be narrower or equal to the capabilities granted to it per the session capability object specified in the inner `AuthSig`. 

When session capability objects are omitted from functions generating session signatures, the SDK will generate a session capability object with **wildcard permissions against all of the resources in that category by default**, i.e. ability to perform operations against all access control conditions. Read more [here](capability-objects) about how to create custom session capability objects.

## Clearing Local Storage

If you want to clear the session key stored in the browser local storage, you can call the [`disconnectWeb3` method](https://js-sdk.litprotocol.com/functions/auth_browser_src.ethConnect.disconnectWeb3.html).

<FeedbackComponent/>

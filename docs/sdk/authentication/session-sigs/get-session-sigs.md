---
sidebar_position: 2
---

import FeedbackComponent from "@site/src/pages/feedback.md";

# Generating SessionSigs

The Lit SDK has three functions that explicitly generate session signatures: `getSessionSigs()`, `getPkpSessionSigs()`, and `getLitActionSessionSigs()`. These functions differ in their parameters and uses, but will all return session signatures.

We recommend using `getSessionSigs()` to specify the abilities of your current session on the Lit Network, using only an `ethers.Wallet` and the `LitNodeClient`. This method is arguably the simplest, enabling your `ethers.Wallet` to perform the specified abilities on the Lit Network. `getPkpSessionSigs()` can be used if your implementation of the Lit SDK involves a PKP and you wish to designate resources to it. Similarly, `getLitActionSessionSigs()` can designate specific abilities and resources to Lit Actions, allowing them to execute code on the Lit Network.


These functions use the session keypair generated by the `LitNodeClient` to invoke a callback function that signs the generated session key, creating an `AuthSig` that is scoped to specific capabilities.

In order to generate `SessionSigs` on both the `Habanero` and `Manzano` networks, you will need to include `capabilityAuthSigs`. This is because transactions on these networks require capacity credits. This will also be the case for the upcoming `datil-test` and `datil-prod` networks. `capabilityAuthSigs` are **not** required on the `datil-dev` network.

You can buy or [mint](../../capacity-credits.md#minting-capacity-credits) capacity credits centrally and [delegate](../../capacity-credits.md#delegating-access-to-your-capacity-credits-nft) them to your users. 

## Storing SessionSigs
 If running the SDK in a Server environment, session signatures may *not* be cached unless you provide an instance of `Storage` to the runtime.
 [Here](https://www.npmjs.com/package/node-localstorage) is an implementation of `LocalStorage` which creates local files to persist storage data.
 If storage is not available, session keys *MUST* be persisted in an external data store. 
 ```javascript
 const LocalStorage = require('node-localstorage').LocalStorage;
 const litNodeClient = new LitNodeClient({
  litNetwork: LitNetwork.DatilDev,
  debug: true,
  storageProvider: {
    provider: new LocalStorage('./storage.test.db'),
  }
 });
 ```

All functions for generating session signatures will try to create a session key for you and store it in local storage. You can also generate the session key yourself using `generateSessionKeyPair()` function and store it however you like. You can then pass the generated session key as the `sessionKey` param.

In the example of `getSessionSigs()` below we construct a SIWE message manually, but you can use the `checkAndSignAuthMessage` when in a browser context.

## getSessionSigs()
Below is an implementation of `getSessionSigs()`. This function can generate session sigs using authentication derived from a PKP or wallet. A key feature of this function that separates it from `getPkpSessionSigs()` and `getLitActionSessionSigs()` is the use of `authNeededCallback`. This property is used to define the `AuthSig` present in the session signatures. [API Docs](https://v6-api-doc-lit-js-sdk.vercel.app/interfaces/types_src.GetSessionSigsProps.html)
```javascript
import dotenv from "dotenv";
dotenv.config({ path: "./process.env" });

import { LitNodeClient } from "@lit-protocol/lit-node-client";
import { 
  LitNetwork,
  LIT_RPC } from "@lit-protocol/constants";
import {
  LitAbility,
  LitActionResource,
  createSiweMessageWithRecaps,
} from "@lit-protocol/auth-helpers";
import { ethers } from "ethers";

// Create a new ethers.js Wallet instance
  let userEthersSigner = new ethers.Wallet(process.env.YOUR_PRIVATE_KEY);
  userEthersSigner = userEthersSigner.connect(
    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_VESUVIUS)
  );

const sessionSigsFunction = async () => {
  // Instantiate a LitNodeClient
  const litNodeClient = new LitNodeClient({
    litNetwork: LitNetwork.DatilDev,
    debug: false,
  });
  await litNodeClient.connect();

  const authNeededCallback = async ({
    uri,
    expiration,
    resourceAbilityRequests,
  }) => {
    // Prepare the SIWE message for signing
    const toSign = await createSiweMessageWithRecaps({
      uri: uri,
      expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(),
      resources: resourceAbilityRequests,
      walletAddress: wallet.address,
      nonce: await litNodeClient.getLatestBlockhash(),
      litNodeClient: litNodeClient,
    });
    // Use the Ethereum wallet to sign the message, return the digital signature
    const signature = await wallet.signMessage(toSign);

    // Create an AuthSig using the derived signature, the message, and wallet address
    const authSig = {
      sig: signature,
      derivedVia: "web3.eth.personal.sign",
      signedMessage: toSign,
      address: wallet.address,
    };

    return authSig;
  };

  // Create a session key and sign it using the authNeededCallback defined above
  const sessionSigs = await litNodeClient.getSessionSigs({
    chain: "ethereum",
    resourceAbilityRequests: [
      {
        resource: new LitActionResource("*"),
        ability: LitAbility.LitActionExecution,
      },
    ],
    authNeededCallback,
  });

  return sessionSigs;
};
```

**Note:** The nonce should be the latest Ethereum blockhash returned by the nodes during the handshake.

## getPkpSessionSigs()
This is an implementation of `getPkpSessionSigs()`. Noticably different from `getSessionSigs()`, it lacks the `authNeededCallback` parameter, instead creating the callback and signing the session key under the hood with the `signSessionKey()` function. [API Docs](https://v6-api-doc-lit-js-sdk.vercel.app/classes/lit_node_client_src.LitNodeClientNodeJs.html#getLitActionSessionSigs)
```javascript
import dotenv from "dotenv";
dotenv.config({ path: "./process.env" });

import ethers from "ethers";
import { LitNodeClient } from "@lit-protocol/lit-node-client";
import {
  AuthMethodScope,
  LitNetwork,
  ProviderType,
  LIT_RPC,
} from "@lit-protocol/constants";
import {
  EthWalletProvider,
  LitAuthClient,
} from "@lit-protocol/lit-auth-client";
import { LitAbility, LitActionResource } from "@lit-protocol/auth-helpers";

const pkpSessionSigsFunction = async () => {
  // Create/Import an ethers.Wallet, connect it to Chronicle Vesuvius
  let userEthersSigner = new ethers.Wallet(process.env.YOUR_PRIVATE_KEY);
  userEthersSigner = userEthersSigner.connect(
    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_VESUVIUS)
  );

  // Instantiate a LitNodeClient
  const litNodeClient = new LitNodeClient({
    litNetwork: LitNetwork.DatilDev,
    debug: false,
  });
  await litNodeClient.connect();

  // Instantiate a LitAuthClient
  const litAuthClient = new LitAuthClient({
    litRelayConfig: {
      relayApiKey: process.env.LIT_RELAYER_API_KEY,
    },
    rpcUrl: LIT_RPC.CHRONICLE_VESUVIUS,
    litNodeClient,
  });

  // Initialize a provider through the litAuthClient, specifying EthWallet
  const userAuthProvider = litAuthClient.initProvider(ProviderType.EthWallet);

  // Generate a wallet signature to use as an AuthMethod
  const authMethod = await EthWalletProvider.authenticate({
    signer: userEthersSigner,
    litNodeClient,
  });

  // Mint a new PKP for the given AuthMethod through the relay server
  const mintedPkpTransactionHash = await userAuthProvider.mintPKPThroughRelayer(
    authMethod,
    {
      permittedAuthMethodScopes: [[AuthMethodScope.SignAnything]],
    }
  );

  // Using the relay server, we can fetch the PKPs that have been minted to the AuthMethod
  const pkps = await userAuthProvider.fetchPKPsThroughRelayer(authMethod);

  // Using the first PKP minted to our AuthMethod, adding that our AuthMethod is authorized
  // to perform the actions defined by the resourceAbilityRequests for the next 10 minutes
  const pkpSessionSigs = await litNodeClient.getPkpSessionSigs({
    pkpPublicKey: pkps[pkps.length - 1].publicKey,
    authMethods: [authMethod],
    resourceAbilityRequests: [
      {
        resource: new LitActionResource("*"),
        ability: LitAbility.LitActionExecution,
      },
    ],
    expiration: new Date(Date.now() + 1000 * 60 * 10).toISOString(),
  });

  return pkpSessionSigs;
};
```
## getLitActionSessionSigs()
Lastly is a simple example of `getLitActionSessionSigs()`. The parameters are similar to `getPkpSessionSigs()`, however this function retrieves sessions signatures specifically for Lit Actions. Unlike `getPkpSessionSigs()` this function requires either `litActionCode` or `litActionIpfsId` and the necessary `jsParams` for executing the provided Lit Action. [API Docs](https://v6-api-doc-lit-js-sdk.vercel.app/classes/lit_node_client_src.LitNodeClientNodeJs.html#getLitActionSessionSigs)
```javascript
import dotenv from "dotenv";
dotenv.config({ path: "./process.env" });

import ethers from "ethers";
import { LitNodeClient } from "@lit-protocol/lit-node-client";
import {
  AuthMethodScope,
  LitNetwork,
  ProviderType,
  LIT_RPC,
} from "@lit-protocol/constants";
import {
  EthWalletProvider,
  LitAuthClient,
} from "@lit-protocol/lit-auth-client";
import {
  LitAbility,
  LitActionResource,
  LitPKPResource,
} from "@lit-protocol/auth-helpers";

const sessionSigsFunction = async () => {
  // Create/Import an ethers.Wallet, connect it to Chronicle Vesuvius
  let userEthersSigner = new ethers.Wallet(process.env.YOUR_PRIVATE_KEY);
  userEthersSigner = userEthersSigner.connect(
    new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_VESUVIUS)
  );

  // Instantiate a LitNodeClient
  const litNodeClient = new LitNodeClient({
    litNetwork: LitNetwork.DatilDev,
    debug: false,
  });
  await litNodeClient.connect();

  // Instantiate a LitAuthClient
  const litAuthClient = new LitAuthClient({
    litRelayConfig: {
      relayApiKey: process.env.LIT_RELAYER_API_KEY,
    },
    rpcUrl: LIT_RPC.CHRONICLE_VESUVIUS,
    litNodeClient,
  });

  // Initialize a provider through the litAuthClient, specifying EthWallet
  const userAuthProvider = litAuthClient.initProvider(ProviderType.EthWallet);

  // Generate a wallet signature to use as an AuthMethod
  const authMethod = await EthWalletProvider.authenticate({
    signer: userEthersSigner,
    litNodeClient,
  });

  // Mint a new PKP for the given AuthMethod through the relay server
  const mintedPkpTransactionHash = await userAuthProvider.mintPKPThroughRelayer(
    authMethod,
    {
      permittedAuthMethodScopes: [[AuthMethodScope.SignAnything]],
    }
  );

  // Using the relay server, we can fetch the PKPs that have been minted to the AuthMethod
  const pkps = await userAuthProvider.fetchPKPsThroughRelayer(authMethod);
  const pkp = pkps[pkps.length - 1];
  const litActionCode = `const go = async () => {
   Lit.Actions.setResponse({ response: "true" });
};

go();
`;

  const litActionSessionSigs = await litNodeClient.getLitActionSessionSigs({
    pkpPublicKey: pkp.publicKey,
    authMethods: [authMethod],
    chain: "ethereum",
    resourceAbilityRequests: [
      {
        resource: new LitPKPResource("*"),
        ability: LitAbility.PKPSigning,
      },
      {
        resource: new LitActionResource("*"),
        ability: LitAbility.LitActionExecution,
      },
    ],
    litActionCode: Buffer.from(litActionCode).toString("base64"),
    jsParams: {},
  });

  return litActionSessionSigs;
};
```
## Resources You Can Request

You can pass an array of `resourceAbilityRequests` to the above functions, which will be presented to the user in the SIWE message - read more [here](resources-and-abilities) about Lit resources and abilities. The resources and abilities requested by the session key must be narrower or equal to the capabilities granted to it per the session capability object specified in the inner `AuthSig`. 

When session capability objects are omitted from functions generating session signatures, the SDK will generate a session capability object with **wildcard permissions against all of the resources in that category by default**, i.e. ability to perform operations against all access control conditions. Read more [here](capability-objects) about how to create custom session capability objects.

## Clearing Local Storage

If you want to clear the session key stored in the browser local storage, you can call the [`disconnectWeb3` method](https://js-sdk.litprotocol.com/functions/auth_browser_src.ethConnect.disconnectWeb3.html).

<FeedbackComponent/>

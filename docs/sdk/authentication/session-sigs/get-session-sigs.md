---
sidebar_position: 2
---

import FeedbackComponent from "@site/src/pages/feedback.md";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Generating SessionSigs: `getSessionSigs`

This guide covers the `getSessionSigs` function from the Lit SDK. For an overview of what session signatures are and how they are to be used, please go [here](./intro).

The function uses the session keypair generated by the `LitNodeClient` to invoke a callback function that signs the generated session key, creating an `AuthSig` that is scoped to specific capabilities.

Using the `getSessionSigs` function, you can specify the abilities of your current session on the Lit network. This function is the simplest way to get session signatures, at the minimum only requiring an `ethers.Wallet` and the `LitNodeClient`. It will enable your `ethers.Wallet` to perform abilities to the resources you specify in the `AuthSig`.

## Prerequisites

Before continuing this guide, you should have an understanding of:
- [Session Signatures](./intro)
- [Lit Resources and Abilities](./resources-and-abilities.md)

## Parameters and Returns

To see the parameters and return of `getSessionSigs`, please visit our [API Docs](https://v6-api-doc-lit-js-sdk.vercel.app/classes/lit_node_client_src.LitNodeClientNodeJs.html#getSessionSigs).

## Example Implementation

The full code implementation can be found [here](https://github.com/LIT-Protocol/developer-guides-code/tree/master/session-signatures/getSessionSigs). 

### Installing the Required Dependencies
<Tabs
defaultValue="npm"
values={[
{label: 'npm', value: 'npm'},
{label: 'yarn', value: 'yarn'},
]}>
<TabItem value="npm">

```bash
npm install \
@lit-protocol/auth-helpers \
@lit-protocol/constants \
@lit-protocol/lit-node-client \
ethers@v5
```

</TabItem>

<TabItem value="yarn">

```bash
yarn add \
@lit-protocol/auth-helpers \
@lit-protocol/constants \
@lit-protocol/lit-node-client \
ethers@v5
```

</TabItem>
</Tabs>

The `node-localstorage` dependency is only required when executing code outside a browser environment. The SDK will use the native browser storage when in a browser environment.

### Instantiating an Ethers Signer
The `ETHEREUM_PRIVATE_KEY` environment variable is required.
```ts
import { LIT_RPC } from "@lit-protocol/constants";
import * as ethers from "ethers";

const ethersSigner = new ethers.Wallet(
  process.env.ETHEREUM_PRIVATE_KEY,
  new ethers.providers.JsonRpcProvider(LIT_RPC.CHRONICLE_YELLOWSTONE)
);
```

### Instantiating a `LitNodeClient`
Here we are instantiating an instance of `LitNodeClient` and connecting it to the `datil-dev` Lit network. To simulate a Node.js environment, we use `LocalStorage` from the `node-localstorage` module to store our session keys and metadata.

```ts
import { LitNodeClient } from "@lit-protocol/lit-node-client";
import { LitNetwork } from "@lit-protocol/constants";
import { LocalStorage } from "node-localstorage";

let litNodeClient: LitNodeClient;

litNodeClient = new LitNodeClient({
      litNetwork: LitNetwork.DatilDev,
      debug: false,
      storageProvider: {
        provider: new LocalStorage("./lit_storage.db"),
      },
    });
await litNodeClient.connect();
```

### Generating Session Signatures
The session signatures generated in this example provide unrestricted access to all resources. However, in real-world applications, it's more common and secure to limit access. Typically, you would use the specific hash of the encrypted access control condition resource key, granting access only to particular resources rather than everything. To this resource, we then give it the ability to decrypt an encryption access control condition. 

```ts
import {
  LitAbility,
  LitAccessControlConditionResource,
  createSiweMessage,
  generateAuthSig,
} from "@lit-protocol/auth-helpers";

const sessionSignatures = await litNodeClient.getSessionSigs({
  chain: "ethereum",
  expiration: new Date(Date.now() + 1000 * 60 * 10 ).toISOString(), // 10 minutes
  resourceAbilityRequests: [
    {
      resource: new LitAccessControlConditionResource("*"),
      ability: LitAbility.AccessControlConditionDecryption,
    },
  ],
  authNeededCallback: async ({
    uri,
    expiration,
    resourceAbilityRequests,
  }) => {
    const toSign = await createSiweMessage({
      uri,
      expiration,
      resources: resourceAbilityRequests,
      walletAddress: ethersSigner.address,
      nonce: await litNodeClient.getLatestBlockhash(),
      litNodeClient,
    });

    return await generateAuthSig({
      signer: ethersSigner,
      toSign,
    });
  },
});
```


**Note:** The nonce should be the latest Ethereum blockhash returned by the nodes during the handshake.

## Clearing Local Storage

If you want to clear the session key stored in the browser local storage, you can call the [`disconnectWeb3` method](https://js-sdk.litprotocol.com/functions/auth_browser_src.ethConnect.disconnectWeb3.html).

## Summary
The full code implementation can be found [here](https://github.com/LIT-Protocol/developer-guides-code/tree/master/session-signatures/getSessionSigs). 

After executing the example implementation above, you will have generated and stored session signatures that allow you to request decrypting data that you satisfied the Access Control Conditions for.

<FeedbackComponent/>
